/*eslint-disable*/
//коллекции это массивы состоящие из объектов
"#### --- { Array Methods } --- ####"
/*
  @@ - возвращает новый не изменяя старый
  ^^ - изменяет старый массив так и возвращает новый
  && - примитив
  <> - объект
  Предикат - логическое выражение основа которого true или false
*/

/*#####>>>>--- ИЗМЕНЕНИЕ СТРУКТУРЫ МАССИВА (Не убавилось, не прибавилось) ---<<<<###### */
//@@ массив разбивает на равные части с остатком или без.
chunk(['a', 'b', 'c', 'd'], 2); // => [['a', 'b'], ['c', 'd']]
//@@ убирает вложенность массива на 1. обычный arr.flat и то полезней
flatten([1, [2, [3, [4]], 5]]);// => [1, 2, [3, [4]], 5] 
//@@ убирает полностью все вложенности в массиве
flattenDeep([1, [2, [3, [4]], 5]]);// => [1, 2, 3, 4, 5]
//@@ тот же arr.flat, но со своим синтаксисом
flattenDepth(array, 1);// => [1, 2, [3, [4]], 5]
/*<> принимает массив с массивами ключ значение*/
fromPairs([['a', 1], ['b', 2]]);// => { 'a': 1, 'b': 2 }
//@@ конвертирует объект в массив с массивами. ключ значение. Не наследует данные из prototype
toPairs({a: 1, b: 2});// => [["a", 1], ["b", 2]]
//@@ так же наследует свойство из prototype
    function Foo() {  this.a = 1; this.b = 2; }
    Foo.prototype.c = 3;//1го уровня данные
toPairsIn(new Foo());// => [['a', 1], ['b', 2], ["c", 3]] 
//&& склеивает по сепаратору. Обычный join
join(['a', 'b', 'c'], '~');// => 'a ~ b ~ c'
//@@ Разворачивает массив
reverse([2, 3, 5, 4]);// => [4, 5, 3, 2]
//@@ принимает массивы и группирует их. массив 1х эл. массив 2х и т.д
//имеет версию zipWith с методом итерации
zip(['a', 'b'], [1, 2], [true, false]);// => [['a', 1, true], ['b', 2, false]]. массив 1х и 2х эл. прошлых массивов
//<> группирует в объект. 1й массив ключи, 2й значения. другое поведение чем у fromPairs
zipObject(['a', 'b'], [1, 2]);// => { 'a': 1, 'b': 2 }
//<> группирует в объект так же + может создать объект на основе путей. 
zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);// => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
//@@ разгруппирует массивы обратно
//имеет версию unzipWith с методом итерации
unzip([['a', 1, true], ['b', 2, false]]);// => [['a', 'b'], [1, 2], [true, false]]


/*#####>>>>---Collection Methods---<<<<###### */
//@@ обычный arr.concat 
concat(array, 2, [3], [[4]]);// => [1, 2, 3, [4]].
//^^ тот же arr.fill заполняет массив значением от - до.
fill(arr1, 'a', 2);// => [2, 3, "a", "a", "a"]


/*#####>>>>--- ФИЛЬТРЫ (Найти и исключить) ---<<<<###### */
//@@ исключает из массива false, null, 0, "", undefined и NaN. return массив
compact([0, 1, false, 2, '', 3]);// => [1, 2, 3]
//@@ исключает из массива те значения которые указываются в любом кол-ве через запятую
without([2, 1, 2, 3], 1, 2);// => [3]
//^^ исключает из массива те значения которые указываются в любом кол-ве через запятую
pull(['a', 'b', 'c', 'd'], 'a', 'c');// => ['b', 'd']
//^^ исключает из массива те значения которые указываются массивом во 2м параметре
pullAll(['a', 'b', 'c', 'd'], ['a', 'c']);// => ['b', 'd'];
//^^ тож самое + критерий. В данном случае по ключу "x"
pullAllBy([{ x: 1 }, { x: 2 }], [{ 'x': 1 }], 'x');// => [{ 'x': 2 }]
//^^ версия с компаратором
pullAllWith([{ x: 1 }, { x: 2 }], [{ x: 1 }], _.isEqual);// => [{ x: 2 }]
//^^ исключает элементы по индексам и массив вырезанных значений. Индекс нач. с 1, а не с 0
pullAt('a', 'b', 'c', 'd', [1, 3]);// => ['b', 'd']
//@@ тот же pullAll, но не изменяет старый массив
//обычный difference не распознаёт объекты для их фильтрования и удаления найденных ключей
difference([2, 1, 5], [2, 3]);// => [1,5]
//@@ + добавляется метод для каждой итерации (Как критерий сравнения). итерация нач. со 2го массива, заканчивается проходом по 1му
//это значит Math.floor сокращает в мен. сторону, делается сравнение, лишнее выводиться как есть
differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor)// => [1.2]
//@@ добавляется метод влияющий на сравнения так же объектов для исключения из 1го массива
//итерация. 1й эл 1 массива - проход по 2му массиву, 2й - эл массива и снова проход 2 массиву и т.д
//итерация. каждый элемент 1го массива проходится полностью по 2му массиву
differenceWith([2, 4], [2, 5], _.isEqual)// => [4]
//@@ исключает последнего элемента в массиве.
initial([1, 3, 4]);// => [1, 3]
//@@ исключает из начала массива 1 и более индексов.  2й пар. n-число. 1й элемент можно не указывать
drop([1, 2, 3]);// => [2,3]
//@@ исключает с конца массива 1 и более индексов. тот же initial только имеет 2й параметр.
dropRight([1, 2, 3, 4, 5], 2);// => [1, 2, 3]
//@@ исключает с конца массива используя Предикат. удаляет пока видит false или true. Пример
let users = [
  { 'user': 'barney',  'active': true },
  { 'user': 'fred',    'active': false },
  { 'user': 'pebbles', 'active': true },
];
dropRightWhile(users, (o)=>!o.active)// => { 'user': 'barney',  'active': true },
//@@ удаление спереди 
dropWhile(users, ['active', true])//вернёт массив с 2мя объектами fred и pebbles
//^^ Работает как filter, возвращает элементы равные условию предиката: true
remove([13, 14, 12, 1, 5], (a)=> !(a % 2))
//@@ возвращает элементы равные условию предиката: true
filter([13, 14, 12, 1, 5])
//@@ возвращает новый массив по на основе старого по указанным позициям индексов
slice([13, 14, 12, 1, 5], 1, 3);// => [14, 12]. Конечный индекс не включительно
//@@ Сравнивает массивы и убирает повторяющиеся элементы из массива. Антоним intersection
//имеет By и With версию
xor([6, 2, 3],[0, 1, 2]);// => [6, 3, 0, 1]
//@@ Убирает повторяющиеся элементы из массива.
//так же имеет версию By и With
uniq([2, 1, 2]);//[2, 1]


/*#####>>>>--- ПОИСК ПО МАССИВУ (Найти и вернуть)---<<<###### */
//&& возвращает 1й эл. массива. Обычный arr.shift вырезает 1й элемент в отличие от head
head([2, 2, 3])// => 2
//возвращает последний эл. массива. Обычный arr.pop, но не изменяет массив
last([1, 2, 3]);// => 3. Антоним initial
//&& тот же findIndex. 2й параметр можно указывать так же как в dropRightWhile
findIndex(arr2, (i) => i === 5)// => 2 индекс.
//&& возвращает последний индекс. 2й пар. и findLastIndex превращается в findIndex
findLastIndex(arr)//принимает так же Предикат (логическое выражение которое при итерации опирается на bool)
//&& обычный arr.indexOf. ищет по значению индекс. 3й пар. "Ищи значение после n индексов". 
indexOf(arr1, 3);// => 1.//установив отрицательное смещение, поиск будет с конца 
//&& 3й пар. звучит так "Ищи значение в первых n индексах"
lastIndexOf([1, 2, 3, 4, 5], 3, 2);// => -1 . Не дотянулся
//&& ищет значение по индексу. Отрицательный индекс ищет с конца
nth([1, 2, 3, 4, 5], 2);// => 3
//@@ сравнивает массивы и возвращает сходство. Объекты не сравнивает
intersection([2, 1], [2, 3])// => 2
//@@ то же действие + критерий сравнения. Можно сравнить объекты по критериям ключа
intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);// => [2.1]
//@@ 3й параметр компаратор сравнения. 2ва аргумента arrVal1, arrVal2. Можно _.isEqual
//Принцип работы. Ищет a1 > a2 пока не достигнет конца или 1го или 2го массива
intersectionWith([2,3,3], [2,2,1], (a1, a2) => a1 > a2);// => [2]-уникальна
//&& Осуществляет двоичный поиск места для значения (бинарный поиск). Возвращает индекс по которому можно вставить в этот массив это значение
//и не потерять сортировку. При несортированном методе т.к. бинарный поиск это постоянное деление массива поровну
//сложно предугадать куда поиск предполагает нахождение данного элемента Запутанный метод. Читать про линейный и двоичный поиск
//На во много раз быстрей происходит поиск дынный чем линейный поиск. Пригодиться при оптимизации запросов от пользователя
sortedIndex()//предварительно нужно отсортировать массив как я понял
sortedIndexBy([0, 1, 2, 3], 7, (a) => a);// => 4. Утверждает что число 7 вписывается под 4м индексом
//&& тот же indexOf, но для сортированного массива. Ищет бинарным поиском наиближайшее предполагаемое место, куда б можно было положить значение
sortedIndexOf([1, 2, 3], 2);// => 1
//&& возвращает индекс предполагаемого того места где бы стояло искомое значение, но уже самым дальним  
sortedLastIndex([4, 5, 5, 5, 6], 5);// => 4
//&& тоже самое + итерация
sortedLastIndexBy ([4, 5, 5, 5, 6], 4, (a) => a);// => 1


"#### --- { Collection Methods } --- ####"
//<> данные массива в объекте будут записаны как ключи и присвоено всем 1
countBy(['a', 'b', 'c']);//{a: 1, b: 1, c: 1}








/*----Бинарный поиск и с чем его едят.
При каком либо поиске определённых значений в некоторых данных, происходит итерация. 
Например поиск какого-то числа в массиве. Любые методы совершающие итерации проверяют каждое значение
и при успехе делают какой-то следующий шаг с этим числом. Или возвращают его или продолжают искать по пути складывая 
значения в массив. Такая операция занимает n- кол-во времени которое зависит от объёма данных в которых происходит поиск. 

Был придумал другой более быстрый алгоритм, который не перебирает каждый элемент, а делит массив пополам
снова и снова до

*/