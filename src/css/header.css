.header {
   background-color: #282c34;
   min-height: 300px;
   border: 2px solid #188;
   margin-bottom: 50px;
   display: grid;

 }
 .header__list {
   list-style-type: none;
 
   height: 100px;
   display: grid;
   grid-template-columns: repeat(6,1fr);/*пока высота не будет задана, выравнивание не произойдёт*/
   justify-items: center;
   align-content: center;
   border: 1px solid yellow;
   margin-bottom: 0px;
   align-self: end;/*работает относительно родителя*/
 }

 .header__fff{
  height: 50px;
  border: 2px solid #000;
  display: grid;
  margin-top: 50px;
  align-self: start;
  
  
}
 .header__item {
   border: 1px solid #000;
 }

 .header__link {
   display: grid;
   justify-content: center;
   align-items: center;
   width: 200px;
   height: 70px;
   border: 1px solid #876;
   text-decoration: none;
   color: #61dafb;
   font-size: 1.7rem;
 }

 /*
  container имеет grid, дочерние элементы занимают равномерную площадь по высоте. При изменении
  размеров дочерних элементов остаётся так же невидимое поле равномерно распределяющее элементы.
  Без родительского вмешательства имеется инструмент перемещений с префиксом self и перемещаться 
  можно только по этим площадям выделенным для каждого элемента. 
  Сокращать дистанцию в таком случае придётся использовав отрицательные значения margin.
  При положительном значении margin, если элементы не упираются, то они будут отталкиваться друг от друга  
  Странное поведение. При отталкивании элементом от другого элемента, центр начинает смещаться 
  в сторону того элемента поэтому 2й(другой) элемент начинает двигаться, но расстояние рассчитывается
  поровну от центра которого не видно 
 */