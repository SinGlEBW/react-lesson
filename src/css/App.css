*,
::before,
::after {
  box-sizing: border-box;
  padding: 0;
  margin: 0;
}

body {
  height: 100vw;
  border: 1px solid #000;
  
}
.container{
  margin: 0 auto;
  width: 1800px;
  border: 1px solid tomato;
  display: grid;
}


.test-block{
  height: 50vh;
  display: grid;
  background-color: #33343A;
}

.test-block__form{
  display: grid;
  grid-row-gap: 20px;
  border: 1px solid red;
  
}
.text-block__items{
  display: grid;
  grid-template-columns: repeat(12,1fr);
  grid-template-rows: repeat(2,1fr);
  
  align-items: center;
  border: 3px solid #000;
  padding: 0 20px;
}
.text-block__item:first-child{
  grid-column: 1 / -1;
}
.text-block__item{
  
}

/*
  Некоторые проблемы с которыми встретился в grid на React. При построении страницы
  2м блоком ставиться container. В grid нужно указывать сетку родителю. в container 
  смысла, ставить сетку, нет. тогда придётся дополнительно делать обёртку или
  отказываться от контейнера. В таком случае обёртки всё равно не миновать, 
  и указывать сетку настраивать можно разного размера для каждой обёртки.
  Не знаю на сколько это актуально, но пока рассматриваю такой вариант в целях 
  выравнивание элементов за счёт сетки. Чтоб лишних элементов сетки не было на которые 
  придётся наезжать если элемент будет находиться не в поле колонки

  При использовании grid-template-rows(columns) на дочерних элементах при использовании
  общего класса нужно понимать что команды grid воздействуют на каждый элемент 
  в отдельности

*/
@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-spin infinite 20s linear;
  }
}
@keyframes App-logo-spin {
  0% {
    color: red;
    transform: rotate(0deg)
  }

  100% {
    color: red;

    transform: rotateX(360deg)
  }

}

/*
grid-column-start: 1;передвижение непосредственно элемента. указав 2му элементу переместиться на позицию 1, он перейдёт 
                     на 2ю строку, а не сдвинет 1й элемент.Перемещение же вправо будет сдвигать элементы строки
grid-column-end: 5; указывает границу до какого элемента
grid-column: 3/5; - альтернативная запись

При обращение к элементам с параметром сдвига в строке, элементы почему-то начинают движение не со своей позиции, а с
левого края сдвигая всё на своём пути

grid-row-start: 1; начало строки
grid-row-end: 3; до какой строки. Освободит строку под элементом если что-то там есть
grid-row: 1/3; альтернатива

другой способ контроля позиций элементов. В родителе можно указать
 grid-template-columns: repeat(12, 1fr);
 grid-template-areas:
        "h h h h h h h h h h h h h"
        "m m c c c c c c c c c c c"
        "f f f f f f f f f f f f f";







Особенности отличий flex от grid:
  1. при объявлении flex переводит колонку в строку, grig делает элементы блочными, но не разворачивает в строку
 
  2. в grid есть понятие "СЕТКА" и добавлены метод и так же изменены методы из flex:
     align-items, justify-items - выравнивают в СЕТКЕ по вертикали и горизонтали, указываются в родителе,
     в то время в flex нет justify-items и align-items просто выравнивает по вертикали.

  3. в grid за простое выравнивание элементов в родителе отвечают методы align-content, justify-content,
     в то время как в flex align-content выравнивает по вертикали если есть 2 и более строк.

  4. у flex для дочернего элемента есть align-self которая выравнивает по той оси которая установлена методом flex-direction, 
     в то время как в grid есть как горизонтальное так и вертикальное управление align-self, justify-self.
###------------------------------------------------------------------------------------------------------------
  Для grid align-content, align-items, align-self одно и тоже, разница лишь в том что можно в отдельности
  управлять одним дочерним элементом через align-self. Для flex тож самое исключая align-content)

  Так же не стоит забывать, что flex - это блок, из-за перехода с колонки в строку блок div растягивается уже не
  по горизонтали, а по вертикали, за это отвечает параметр на дочерний эл. align-self: по ум stretch 

  Интересная особенность. При указании flex или grid дочерний элемент растягивается по высоте родителя.
  За высотой родителя нужно следить, тогда из-за растянутого дочернего элемента не возникнет проблем
  использовать align-content
  Так же при добавлении элементов, в растянутый блок родителя при использовании grid, они распределяются 
  равномерно по вертикали 
###-------------------------------------------------------------------------------------------------------------
  
      
  Не допускать в grid
1. Если идёт управление размером через родителя, то указывать размер в дочернем элементе не стоит
  не смотря на то что размер дочернего элемента мы изменим, значение родителя не поменяется
  и ориентироваться придётся на установленный размер родителя, что не очень удобно и приводит к непредсказуемым результатам.

*/

/*
  Различия подходов flex и grid.
  Что бы выровнять во flex и grid элементах дочерний элемент с контентом, требуется дочернему элементу(тобишь родителю для своей вложенности)
  задать размер после добавить display: flex(grid) и далее jc-center. 
  в grig есть понятие колонок в связи с которыми приходиться вводить доп параметры в родителе
  Пример.
  Из-за того что в grid выставлены колонки в родителе, для выравнивания элементов в них, в родителе задаётся есть параметр для колонок
  justify-items: center. Во flex не пришлось бы ничего указывать дополнительно т.к. он не строит колонки 
 
*/