/*eslint-disable */
<Fragment></Fragment> //пустая обёртка или так <> </> 
props.children - /*свойство отображает что заложено между тегов родительского компонента*/
   
<SplitPane left={ <Contacts />} right={ <Chat /> } />
 
/*При итерации можем передать что-нибудь в событие*/ 
   
arr.map((item) => (
  <div onClick={(e)=>{ this.evChange(e, item.number) }}>item.number</div>
))

/*
Заметка
Иногда при построении сайтов предусматривают вариант для людей с ограниченными возможностями
Когда проектируются такие решения нужно использовать не camelCase а kebab-case.
В React есть атрибут aria-* и целый список возможностей. 
*/

const Component = React.createContext('light');//создание контекста. Принимает defaultValue
/* Оборачиваем и передаём что надо */
<Component.Provider value="dark"> 
  <MyComponent />
</Component.Provider>
/* конкретно в классовой компоненте пишем так, что бы данные были в объекте context */
class newComponent {
  static contextType = Component;
}
/*
Если много чего передавать, можно взять нижний компонент по структуре закинуть в верхний
там снабдить его данными и спустить по структуре этот компонент, такой подход не всегда оправдан
и перегружает в некоторых случаях компоненты через которые передаётся данный компонент  
*/
/**---ХУКИ----*/
useEffect(()=>{}) //тот же componentDidMouth  
let ref = useRef(null);//присвоив переменную ref компоненту, получим доступ к DOM элементу

/*--СОБЫТИЯ--*/
onFocus//реагирует при фокусировке на элементе
/* свойства и методы класса event */
/*
  В React над обычным объектом Event есть обёртка SyntheticEvent которая при вызове события 
  передаёт данные в event и очищается. (сделано это дял производительности. Поэтому я ничего там
  не видел, только после вызова). Что бы исключить этот объект из потока и использовать асинхронно
  нужно вызвать e.persist()
*/
e.bubbles//является ли событие всплывающим в DOM :=> bool
e.cancelable//является ли событие отменяемым :=> bool
e.charCode//хз но вместо кода клавиши возвращает 0
e.ctrlKey//был ли нажат Ctrl
e.shiftKey//был ли нажат Shift

e.currentTarget//target тот на котором висит событие. Не важно если кликаем на дочерний элемент
e.target//если событие на родителе, то в target попадает тот элемент на который тыкнули
e.defaultPrevented//информирует был ли в событии установлен e.preventDefault() :=> bool
e.detail//возвращает число кликов по событию. Клики засчитываются если интервал чуть меньше секунды иначе сбрасывается 
e.dispatchConfig//описывает что за событие отработало
e.eventPhase//возвращает число типа event: Ev.NONE = 0 Ev.CAPTURING_PHASE = 1 Ev.AT_TARGET = 2 Ev.BUBBLING_PHASE = 3
e.getModifierState("Shift")//была ли нажата. На всю клавиатуру не распространяется, только определённые кнопки. читать Modifier keys on Gecko
e.keyCode || e.which //определяют код клавиши 
e.type//определяет чем нажато. Смысла от этого нет т.к. я определяю событиями мыши или клавы 
e.timeStamp//показывает число в промежутке времени котором было отработано событие
e.nativeEvent//js нативый event

