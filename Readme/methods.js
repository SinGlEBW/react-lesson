/* eslint-disable */
let str = 'loginLink=Hello&passwordLink=Word';
str.match(/loginLink/g);//можно покопаться в строке и вернуть какое-то слово если оно там есть. Возвращает массив
str.split();//разбивает строку на массив по сепаратору
str.includes('loginLink', 2);//ищет с начала. 2й пар. делает сдвиг с начала. если находит кусок возвращает bool
str.endsWith('loginLink', 2);//ищет с конца. 2й пар. делает сдвиг с конца. возвращает bool

str.repeat(2);//повторит строку 2 раза
str.concat();//соединяет минимум 2 строки и возвращает строку
str.replace(regexp|substr, newSubStr|function(){});//что найти, на что заменить. Возвращает обработно строку
str.indexOf('Hello');//возвращает индекс 1го вхождения. 
str.search('Hello');//возвращает индекс 1го вхождения. Принимает так же рег.выр. 
str.slice(0, 10);//откуда, покуда обрезать строку принимает индекс. 
str.substr(0, 10);//Это старый вариант как и substring одно и то же. Новый slice 
str.charAt(5);//возвращает символ по данному индексу. Естественно тип строка
str.toLowerCase();//приводит в нижний регистр
str.toUpperCase()//приводит в верхний регистр
str.trim();//обрезает пробелы
//Это экспериментальная технология
str.padStart(10, "этим");//чем заполнить первые 10 ячеек данной строки
str.padEnd(10, "дополним");//строка входит в учёт 1го параметра, если что-то останется от 10ти, то 2й пар дополнит строку
/*--------------------------------------------------------------------------------------------------------------------------------------------*/
let arr = [10, 20, 30, 40, 50, 60, 70, 80];

arr.pop();//удаление в конце массива
arr.push();//добавление в конце массива
arr.shift();//удаление в начале массива
arr.unshift();//добавление в начале массива

arr.includes();//есть ли в массиве искомая строка
arr.concat();//склеивает 2 и более массивов
arr.slice();//принцип тот же как со страковым slice. Откуда,покуда. Возвращает массив не изменяя основной
arr.indexOf();//тот же принцип как и в string

arr.splice(1,0, 'ss');
/*
    splice - изменяет основной массив вырезая у него кусок откуда, покуда и что 
    вместо него вставить. Вырезаный же кусок splice возвращает.
*/
arr.copyWithin(3, 1)//3й необ.
   /* Счёт как положено с 0. 
      1й с какого индекса (включительно) класть копию
      2й с какого индекса (включительно) начать делать копию
      3й где закончить. этот индекс не захватываеться. (3й пар. (индекс) - 2й пар. (индекс) = копия )
   */
arr.fill(100, 1, 4);//заполняет числом 100 от 1 индекса до 4. Передав таким образом массив, метод его не раскидает, а целиком будет совать в каждую ячейку

arr.join();//склеивает массив в строку. Принимает разделитель 
arr.toString();//тот же join но без сепаратора

/**######--Переборы--######## */
arr.forEach(()=>{});//цикл
arr.map(()=>{});//тот же forEarch только может возвращять резуоттат  

let count = 0;
let some = arr.some(elem => {
    if(elem === 60)
        return true
    count++;
    console.dir(count);//перебирает до тех пока не найдёт. Потом выходит
})
arr.find((item) => (item === 'какой-то элемент'));//возвращает найденный в массиве элемент
//аналогично если был forEach с командой break; 

arr.reduce();//находит сумму всего массива.
//Пример
let summ = arr1.reduce((timeSum, item) => {

  return timeSum + item;
}, 0);//начальное значение. total называется.
/*
  ПРОЧИТАТЬ. 
  Всё что нужно знать это то, что reduce это обычный цикл, передав reduce 2му параметру начальное значение
  мы в callback во 2м параметре получаем перебор цикла от с 1элемента и до конца,
  Если не передать total, во 2й параметр callback'a цикл массива начинается
  со 2 элемента массива и цикл будет на одну итерацию меньше. 
  Так что лучше всегда предавать, что бы не было путаницы
  
  1й же параметр получает total если он есть, если нет то получает 1й элемент массива
  при первой итерации, а далее параметр ожидает изменения над ним на каждой итерации 
  и возврат этих изменений. 1й параметр как бы сохраняет изменения на итерации и передаётся 
  в следующую итерацию для дальнейших изменений. В конечном итоге после всех изменений
  возвращается reduce именно этот параметр.
  Если ничего не вернуть, то ничего и не будет. А если вернуть, 1й параметр
  работает как бы с запозданием на 1 итерацию 

  3й параметр это индексы
  ВАЖНО reduce не привязан к определённому типу возвращаемых данных.
  Что должен вернуть метод определяет программист.
  На основе массива можно вернуть объект 
  */
const arr1 = [
  { test: [1] },
  { test2: [2] },
  { test3: [3] },
  { test4: [4] },
  { test5: [5] },
  { test6: [6] },
  { test7: [7] }
];
let ob = arr1.reduce((a, b) => { 
    return {...a,...b};
});

console.dir(ob);
//сокращённая запись
arr1.reduce((a, b) => ({...a,...b}));
//из 2х массивов объект
let arr3 =  ['a', 'b', 'c'];//ключи
let arr4 = [7, 2, 5];//значения

arr3.reduce((acc, n, i) => (acc[n] = arr4[i], acc), {})

/*
   Зная что acc на 1й итерации это пустой объект, а n это 1й элемент массива,
   и зная о том что свойства можно создавать обращаясь к объекту просто через точку
   и через синтаксис массива, то нам нужно на каждой итерации создавать разные свойства
   а не одно и тоже поэтому поэтому обращение через []. Возвращаем acc
*/

//Сложный вариант для понимания
const arr2 = [//массив что-то типа ключ - значение
  "test", 16 ,
  "test2", 2 ,
  "test3", 3 ,
  "test4", 4 ,
  "test5", 5 ,
  "test6", 6 ,
  "test7", 7 ,
];
//(!(c%2)) - 0%2 = 0, 1%2 = 1, для if 0 = false поэтому !0 = true и получаем чётные цифры


let ob1 = arr2.reduce((a, item, inx, _this) => { 
    
  if(!(inx%2))
     a[item] = _this[inx+1]
  
  return a
}, {});

//сократить
let ob2 = arr2.reduce((a, item, inx, _this) => (
  (!(inx%2))?a[item] = _this[inx+1] : null, a), {});
console.dir(ob1);

/*
  Массив нужно разбить на чётные(ключи) и нечётные(значения) для этого нужно делить 
  с остатком на 2 и получать будем 0 и 1. Ключи будут отмечаться 0, 0 = false 
  значит !false. 
  Берём объект создаём свойство через ключ и чтоб присвоить значение(а в этой итерации его нет)
  обращаемся через 4й параметр this и выбираем тот индекс в котором находимся + 1,
  то есть следующее значение массива.  
*/

/*-------------------------------------------------------*/
let arrOb = {};
for(let i of arr1) Object.assign(arrOb, i) //проще

console.dir(arrOb);

let arrObj = {};
arr1.forEach((i) => Object.assign(arrObj, i) ) //или

console.dir(arrObj);

/**######-----------######## */


arr.filter((item)=>{
    return item > 30;
});//возвращает отфильтрованый массив
arr.sort((value1,value2)=>{
    return (value2 - value1)
});//возвращает сортированый массив. Изменяет основной. Сортирует от меньшего к большему и на оборот. Всплытие пузырька про который я смотрел
//и т.д. некоторые не записал. работа с bool
/*--------------------------------------------------------------------------------------------------------------------------------------------*/
let obj = {
    name: 'Alex',
    age: 21,
    city: 'NewYork',
    number: 15,
    [Symbol('foo')]: 'sikret',//такое свойство не изменить
    get _number(){  return this.number  },
    set _number(value){
      if(value > 0 && value <= 20)
        this.number = value 
      else{
        let strErr = (value < 0)? 'Меньше: 0' : 'Больше: 20';
        console.dir(strErr);
      } 
    }
}

let obj1 = Object.assign({}, obj);//ES5 копировать объект в новый. Передать можно много объектов
let obj2 = {...obj1};//ES6

obj._number = 21;
console.dir(obj);
/*
  На вопрос: "Что такое десткриптор" - это некий контролирующий функционал который можно изменять влияя на 
  доступ, изменение и удаление свойст и методов, точно не уверен возможно и объектов.
  и имеет некий контролирующий функционал для этого свойства. Например напрямую через метод defineProperty
  или косвенно через set и get.  
  Что нам даёт set и get. По сути мы же может обратиться напрямую к свойству и его изменить.
  Да можем. Обращаясю через set и get мы может устанавливать (контролировать) логику изменения для свойства
  т.к. внутри объекта set и get ведут себя как функции.
  Конечно что бы нельзя было напрямую что то менять в свойстве то есть defineProperty
*/

Object.defineProperty(obj, 'name1', {
    enumerable: false,//будет ли св-во перечисляемым
    configurable: false,//можно ли удалять c помощью delete, модифицировать св-во
    writable: false,//можно ли изменить значение
    value: 'Борис',//значение свойства
   
  });
  /*
    дабавление свойства объекту которое можно контролировать.
    1е. в какой объект
    2е. какое свойство
    3е. объект параметров для этого свойства.
    НЕДОСТАТОК. такой метод нужно на каждое свойство
  */
  obj.name1 = 'ss';//не изменится
  delete obj.name1;//не удалиться
//для многих свойств
  Object.defineProperties(obj, { 
    name1: {
      enumerable: false,//будет ли св-во перечисляемым
      configurable: false,//можно ли удалять c помощью delete, модифицировать св-во
      writable: false,//можно ли изменить значение
      value: 'Борис'//значение свойства
      },
    name2: {
      enumerable: false,//будет ли св-во перечисляемым
      configurable: false,//можно ли удалять c помощью delete, модифицировать св-во
      writable: false,//можно ли изменить значение
      value: 'Петян'//значение свойства
    }
  });

  Object.freeze(obj);//замораживает объект, устанавливая дескрипторы configurable и writable в false.

  let dest = Object.getOwnPropertyDescriptor(obj, 'name1');//узнаёт состояние дескрипторов


 Object.create();//Если требуеться передать объекту узел prototype в наследство. Читать в конце ООП main.js



 /*
   *********** Общие методы не привязанные к объектам **********
 */
 

 parseFloat('4ffffeeee');//принимает строку если строке есть 1е число то вернёт его типом Number иначе NaN 
