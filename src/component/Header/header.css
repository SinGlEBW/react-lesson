.header {
  display: grid;
  background-color: #282c34;
  border: 3px solid #000;
  background: url(/image/header.jfif);
  background-size: cover;

 }
.header__wrap{
  display: grid;
  grid-template-rows: 6fr 1fr 1fr;
  border: 1px solid green;
}
.header__nav {
  list-style-type: none;
  display: grid;
  grid-template-columns: repeat(6,1fr);/*пока высота не будет задана, выравнивание не произойдёт*/
  justify-items: center;
  align-content: end;
  padding-bottom: 50px;
  
}
.header__navItem {
  box-shadow: 0px 0px 20px red;
  border: 3px solid #000;
}

.header__navItemlink {
  display: grid;
  justify-content: center;
  align-items: center;
  width: 200px;
  height: 70px;
  border: 1px solid #876;
  text-decoration: none;
  color: #61dafb;
  font-size: 1.7rem;
}

.header__lkBtn{
  display: grid;
  grid-template-columns: repeat(12, 1fr);
  align-items: center;
  grid-gap: 20px;
  padding: 0 20px;
  border: 1px solid #000;
}

.header__lkBtnItem{
  display: grid;
  justify-items: center;
  align-items: center;

  width: 100%;
  height: 45px;
  border-radius: 4px;
}
.header__loginIn{
  display: grid;
  
}
.header__loginInItem{
  
}
 /*
  container имеет grid, дочерние элементы занимают равномерную площадь по высоте. При изменении
  размеров дочерних элементов остаётся так же невидимое поле равномерно распределяющее элементы.
  Без родительского вмешательства имеется инструмент перемещений с префиксом self и перемещаться 
  можно только по этим площадям выделенным для каждого элемента. 
  Сокращать дистанцию в таком случае придётся использовав отрицательные значения margin.
  При положительном значении margin, если элементы не упираются, то они будут отталкиваться друг от друга  
  Странное поведение. При отталкивании элементом от другого элемента, центр начинает смещаться 
  в сторону того элемента поэтому 2й(другой) элемент начинает двигаться, но расстояние рассчитывается
  поровну от центра которого не видно 
 */