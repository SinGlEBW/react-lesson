.header {
  display: grid;
  background-color: #282c34;
  border: 3px solid #000;
  background: url(/image/header.jfif);
  background-size: cover;

 }
.header__wrap{
  display: grid;
  grid-template-rows: 400px max-content;
  border: 1px solid green;
}
.header__nav {
  list-style-type: none;  
  display: flex;
  justify-content: space-around;
  align-items: flex-end;
  
  padding-bottom: 50px;
  border: 1px solid #000;
}
.header__navItem {
  box-shadow: 0px 0px 20px red;
  border: 3px solid #000;
}

.header__navItem-link {
  display: grid;
  justify-content: center;
  align-items: center;
  width: 200px;
  height: 70px;
  border: 1px solid #876;
  text-decoration: none;
  color: #61dafb;
  font-size: 1.7rem;
}

.header__auth{
  display: grid;
  grid-template: repeat(1, minmax(0, max-content)) / repeat(12, minmax(0, max-content));
  grid-gap: 20px;
  padding: 10px 0;
  border: 3px solid #000;
}

.header__auth-btn{
  display: grid;
  justify-items: center;
  align-items: center;

  width: 150px;
  height: 45px;
  border-radius: 4px;
}

 /*
  container имеет grid, дочерние элементы занимают равномерную площадь по высоте. При изменении
  размеров дочерних элементов остаётся так же невидимое поле равномерно распределяющее элементы.
  Без родительского вмешательства имеется инструмент перемещений с префиксом self и перемещаться 
  можно только по этим площадям выделенным для каждого элемента. 
  Сокращать дистанцию в таком случае придётся использовав отрицательные значения margin.
  При положительном значении margin, если элементы не упираются, то они будут отталкиваться друг от друга  
  Странное поведение. При отталкивании элементом от другого элемента, центр начинает смещаться 
  в сторону того элемента поэтому 2й(другой) элемент начинает двигаться, но расстояние рассчитывается
  поровну от центра которого не видно 
 */