const { colors } = require('@material-ui/core');
/*eslint-disable*/

const cors = require('cors');

cors({
	origin,
	maxAge,
	methods,
	credentials,
	exposedHeaders,
	allowedHeaders,
	preflightContinue,
	optionsSuccessStatus,
})

/*
Любой сайт это почти всегда совокупность сервера(фронтенд) и сервера(бекенд) + сервера(бд)
CORS - Cross-origin resource sharing (кросс-доменный запрос) — технология 
       современных браузеров, которая позволяет предоставить веб-странице доступ
       к ресурсам другого домена. Призванной обеспечить безопасность,
       или наоборот, поставить веб-приложение под удар.

По умолчанию без использования CORS браузеры ограничивают доступ к сайту и его ресурсам 
с другого домена так же не разрешают AJAX-запросы с сайта на сайты.
В Web это называется Политика Общего Происхождения.

Если бы этого не было то могла бы возникнуть такая ситуация.
Предположим мы случайно кликаем по вирусной ссылке. Данная ссылка перенаправляет нас на «вредоносный сайт», 
имеющий встроенный iframe, который загружает сайт нашего банка и успешно авторизуется там с помощью наших кук.

Насколько я понимаю переходя по какой-то ссылке сервер отправит на тот домен нашу куку, а так как мы сохраняем 
аутентификацию сайта в куках, то он теоретически мог бы зайти на этот сайт и наши куки которые теперь у него активизировали
этот сайт.

CORS определяет набор заголовков, которые позволяют серверу и
браузеру определять, какие меж-доменные запросы разрешены, а какие нет

ВАЖНО*
Запрос включает заголовок Origin в котором указывается домен с которого идёт запрос.
На основании Origin Web приложение(тот или иной сервер - BE,FE,S) либо принимает запрос, либо отвергает его. 
Если запрос принят, запрашиваемый сервер ответит заголовком Access-Control-Allow-Origin

Некоторые заголовки ответа
Access-Control-Allow-Origin: * || <origin> || null. Установив *  позволяет любому домену 
                              в Интернете получать доступ к ресурсам этого сайта. Злоумышленникам
                              тоже.
Access-Control-Allow-Methods: определяет, какие HTTP-запросы (GET, PUT, DELETE и т. д.) 
                              могут быть использованы для доступа когда site.com обращается к ресурсам site.ru.
Access-Control-Max-Age: указывает время жизни пред-запроса доступности того или иного 
                        метода, после которого должен быть выполнен новый запрос на тот или иной метод.
                        
Допустим, мы хотим получить информацию о пользователе на нашем сайте www.mywebsite.com с
сервера, расположенного на сайте api.website.com.

Пример: 

###Удачный запрос с www.mywebsite.com на api.website.com
GET /users
Host: api.website.com
Origin: http://www.mywebsite.com
Предположим на сервере запрос принят то увидим
Access-Control-Allow-Origin: http://www.mywebsite.com


###Не удачный запрос с www.anotherdomain.com на api.website.com
GET /users
Host: api.website.com
Origin: http://www.anotherdomain.com
Запрос на сервере непринят то увидим ошибку Access to fetch has been blocked by CORS policy


При каждом HTTP запросе к этому домену (api.website.com) браузер подставляет значение cookie, 
созданные для http://www.mywebsite.com домена.

К примеру: 
При авторизации в goodsite.ru, cookie генерируются и хранятся для этого домена.
Веб-приложение goodsite.ru основано на технологии SPA и содержит REST API (то есть возможность запросов на бэк по этому адресу)
на goodsite.ru/api для взаимодействия с помощью AJAX.
Предположим, что мы просматриваем badsite.ru, будучи авторизованным на goodsite.ru.
Без ограничения Access-Control-Allow-Origin (с указанием сайта) badsite.ru может выполнить
любой разрешенный аутентифицированный запрос к goodsite.ru, 
даже не имея прямого доступа к сессионной cookie!

REST - REpresentational State Transfer. Сервисы REST позволяют наилучшим образом использовать протокол HTTP,
       Вроде как это технология Запросов и ответов
HTTP — Hyper Text Transfer Protocol - определяет форматы запроса ответа 
URI — Uniform Resource Identifier (универсальный идентификатор ресурса) - как я понял
      это подразумевается создание разработчиком универсального идентификатора для запроса
      к примеру всё что связано с user: GET /users/1 POST /users DELETE /users/1 - users это и есть URI

Hostname - имя сайта www.lesson.ru Domain можно тоже сказать что это имя сайта
Domain - это часть Hostname. Точки разделяют на уровни. Первый уровень самый правый, последний левый.
Меж-доменные запросы - считаются если домен отличается по:

Протоколу http, https
Любая часть домена www, api, ru, net
Порт 3000 3001
*/

"Возможности заголовков"
/*
	1. Http запросы бывают 1.0 и 1.1 Если клиент поддерживает запрос 1.0 то и сервер выберет минимальную поддержку

		 Так же Http 1.0 по умолчанию на сервере клиента при запросе и получению ответа закрывается по умолчанию на сервере 
		 при ответе так же закрывается. Вообщем 1.0 работает на закрытие в любом случае.
		 Http 1.1 по умолчанию держит открытым соединение даже при получении на клиенте файла если не было передано заголовка
		 Connection: close. Нужно это для того что бы в одном запросе передать сразу несколько файлов. Например html, css, js.
		 Соединение такое живёт не долго около 10с  
	2. Http запрос имеет: 'Строку запроса', 'Заголовки', 'Тело запроса' 
	2. Заголовками можно кешировать на клиенте файлы что бы по 100 раз не присылать с сервера при очередном запросе
	3. Так же можно сжимать файлы или передавать в других языковых кодировках
	4. Http является протоколом запрос - ответ. Соединение напрямую не поддерживается
			Дополнительные заголовки расширяют возможности протокола
	5. Http может регулировать открытия и закрытие соединения канала между сервером и клиентом
	6. Http работает по верх TCP/TLS, этим протоколам нужно гарантированное надёжное соединение

	Другие протоколы могут работать по верх UDP

	Имена заголовков не могут содержать пробелы


### <{ ОБЩИЕ ЗАГОЛОВКИ }> ###

	Cache-Control: max-age=3600, public
			Используется для механизма кэширования по цепочке запросов/ответов».
			Эти кэширования включают шлюзы и прокси, которые может использовать интернет-провайдер.
			Разрешение кэширования вашего сайта может снизить нагрузку на сервер и пропускную способность,
			а также увеличить время загрузки в браузере.
			"public" означает, что ответ может быть кэширован кем угодно.
			"max-age" указывает, сколько секунд действителен кеш. 
			"no-cache" Кэширование предотвращено 
	
	Content-Disposition: attachment; filename="download.zip"
			Это заставит браузер открыть окно для предварительной закачки файла "Открыть", "Сохранить", "Закрыть"
			Content-Type: application/zip должен так же присутствовать такого же формата

	Content-Type: text/html; charset=UTF-8
			указывает type документа. "text" - это тип, а "html" - подтип документа. 
			Выбор вариантов: "image/gif" - GIF, "application/pdf" - PDF, "audio/mpeg" - MP3, "text/css"
			Вообщем куча. Смотреть Список mime-type.

	Content-Length: 2135
			Указывает размер отсылаемого контента в байтах 

	Connection: "keep-alive" 
			Каким должно быть соединение. "close" Закрыть соединение после прочтения файла. 
			Можно указать Content-Length после определённого размера соединение закроется

	Content-Encoding: gzip
			Содержит информацию в каком формате закодирован файл

	Transfer-Encoding
			Содержит информацию в каком формате будем передавать файл на сервер
			chunked говорит о том что файл будет передаваться по кусочкам. Это нужно тогда когда веб сервер не знает
			точную длину файла
	
	Upgrade 
			Отвечает за управление между двумя непосредственно соединёнными узлами. Http может работать через посредника
			то есть proxy. Клиент -> СЕРВЕР -> Сервер. Upgrade работает с соединением 1-2 или 2-3. Вообщем читать надо

### <{ ЗАГОЛОВКИ ЗАПРОСА }> ###

	Host: net.mySite.com
			Это в основном имя host, включая домен и поддомен.
	Accept-*заголовки такого рода указывают разные форматы и содержимое документа которые браузер бы мог принять с 
			сервера 
			
	Accept-Language: en-us,en;q=0.5 //Этот заголовок отображает настройки языка по умолчанию. 
	 		Если сайт имеет разные языковые версии, он может перенаправить нового surfer на основе этих данных.
	
	Accept-Encoding: gzip,deflate
			Браузеры поддерживают gzip и отправляют в header. Сервер может отправить HTML-код в сжатом формате.
			Это позволяет уменьшить размер до 80% для экономии пропускной способности и времени.
	
	Cookie: PHPSESSID=r2t5uvjq435r4q7ib3vtdjq120; foo=bar
			cookie это файлы, хранящие пары name=value находящиеся в нашем браузере для этого домена.
			http соединение работает запрос ответ и на очередной запрос мы можем не обязательно подключиться именно
			к тому серверу к которому подключались ранее. Что бы новый сервер понял кто это делает запрос к нему запрос
			мы передаём ему cookie сессии обработав которую на сервере мы понимает кто это и отсылаем нужный ему ответ

	If-Modified-Since: Sat, 28 Nov 2009 06:38:19 GMT
			Если веб-документ сохранен в кеше браузера и мы запрашиваем его снова, браузер может проверить, был ли документ обновлён, отправив этот заголовок:
			Если на сервере файл содержит такую же метку времени, то есть файл не изменялся и дата та же, сервер
			отправляет код ответа «304 Not Modified», без содержимого и браузер загружает содержимое из cache.
		

	If-None-Match: "pub1259380237;gz"

	User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.1.5) Gecko/20091102 Firefox/3.5.5 (.NET CLR 3.5.30729)
			описывает: Имя и версия браузера. Название и версия операционной системы. Язык по умолчанию.

	Referer: https://net.tutsplus.com/
			Если перейти с одной страницы на другую, referer будет содержать адрес первой страницы. То есть откуда клиент перешёл.

	Authorization 
			Отвечает за передачу логина пароля или работой с token
	...

### <{ ЗАГОЛОВКИ ОТВЕТА }> ###:
	Date: отправляет дату сервера. Нужно это для того что бы понимать разницу в часовых поясах клиента и сервера.

	Etag: "pub1259380237;gz"
			Это еще один header, который используется для кеширования. Как я понял при запросе к серверу мы отправляем
			этот заголовок с каждым файлом. Браузер кэширует файлы. При очередном обращении к серверу браузер 
			отправит If-None-Match: "pub1259380237;gz" если значение Etag документа совпадает с этим,сервер 
			отправит код 304 вместо 200, без содержимого. Браузер будет загружать содержимое из своего кеша.

	Last-Modified: <имя-дня>, <номер-дня> <имя-месяца> <год> <час>:<минута>:<секунда> GMT
			Когда сервер возвращает файлы 1й раз для каждого файла устанавливаем этот заголовок с меткой времени
			Эта дата храниться в файловой системе. При очередном запросе данного файла браузер отсылает на сервер
			If-Modified-Since: с этой меткой времени. Если изменений не было то сервер вернёт отправит 
			304 вместо 200 и без содержимого. Браузер будет загружать содержимое из своего кеша.
			
	Location: https://net.tutsplus.com/
			К примеру был запрошен с сервера какой-то документ которого на этом сервере нет, то в таком случае
			мы можем передать статус 301 или 302 и заголовок с URL где его можно получить.
			Браузер тогда сделает запрос на тот сервер перейдя туда.


	Set-Cookie: session-id=120-7333518-8165026; path=/; domain=.amazon.com; expires=Sat Feb 27 08:00:00 2010 GMT
			установление клиенту куки с некоторым id даёт возможность в последующем получать от него эту куку 
			при каждом обращении к серверу, что даёт возможность понимать кто делает запрос на сервер 
			res.cookie()
			

	WWW-Authenticate: Basic realm="Restricted Area"
			Когда браузер увидит этот header, он откроет диалоговое окно входа в систему.

	Server: аналог User-Agent только содержит информация о сервере
*/

"МЕТОДЫ"
HEAD /*тот же GET но возвращает всё кроме тела документа. То есть заголовки и статусы ответа. Если после этого
			 запроса стало понятно что документ устарел судя по описанным заголовкам, то можем сделать полноценный
			 GET запрос */
GET /*запрос на получение данных с сервера */
POST /* отправка произвольных данных на сервер. */
PUT /* так же отправка данных. Используется загрузка по указанному URL на сервер. */
DELETE /* Удаление документа */
/* На публичных серверах эти методы отключают что бы ни кто не мог ничего загружать туда куда не следует */
CONNECT, TRANCE, OPTIONS /* Так же редкие методы */
COPY, MOVE, MKCOL /*расширение WebDav даёт эти методы, но они редкие */
