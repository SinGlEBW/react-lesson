let str = 'loginLink=Hello&passwordLink=Word';
str.match(/loginLink/g);//можно покопаться в строке и вернуть какое-то слово если оно там есть. Возвращает массив
str.split();//разбивает строку на массив по сепаратору
str.includes('loginLink', 2);//ищет с начала. 2й пар. делает сдвиг с начала. если находит кусок возвращает bool
str.endsWith('loginLink', 2);//ищет с конца. 2й пар. делает сдвиг с конца. возвращает bool

str.repeat(2);//повторит строку 2 раза
str.concat();//соединяет минимум 2 строки и возвращает строку
str.replace(regexp|substr, newSubStr|function(){});//что найти, на что заменить. Возвращает обработно строку
str.indexOf('Hello');//возвращает индекс 1го вхождения. 
str.search('Hello');//возвращает индекс 1го вхождения. Принимает так же рег.выр. Но это избыточно т.к. всё можно и так найти
str.slice(0, 10);//откуда, покуда обрезать строку принимает индекс. 
str.substr(0, 10);//Это старый вариант как и substring одно и то же. Новый slice 
str.charAt(5);//возвращает символ по данному индексу. Естественно тип строка
str.toLowerCase();//приводит в нижний регистр
str.toUpperCase()//приводит в верхний регистр
str.trim();//обрезает пробелы
//Это экспериментальная технология
str.padStart(10, "этим");//чем заполнить первые 10 ячеек данной строки
str.padEnd(10, "дополним");//строка входит в учёт 1го параметра, если что-то останется от 10ти, то 2й пар дополнит строку
/*--------------------------------------------------------------------------------------------------------------------------------------------*/
let arr = [10, 20, 30, 40, 50, 60, 70, 80];

arr.pop();//удаление в конце массива
arr.push();//добавление в конце массива
arr.shift();//удаление в начале массива
arr.unshift();//добавление в начале массива

arr.includes();//есть ли в массиве искомая строка
arr.concat();//склеивает 2 и более массивов
arr.slice();//принцип тот же как со страковым slice. Откуда,покуда. Возвращает массив не изменяя основной
arr.indexOf();//тот же принцип как и в string

arr.splice(1,0, 'ss');
/*
    splice - изменяет основной массив вырезая у него кусок откуда, покуда и что 
    вместо него вставить. Вырезаный же кусок splice возвращает.
*/
arr.copyWithin(3, 1)//3й необ.
   /* Счёт как положено с 0. 
      1й с какого индекса (включительно) класть копию
      2й с какого индекса (включительно) начать делать копию
      3й где закончить. этот индекс не захватываеться. (3й пар. (индекс) - 2й пар. (индекс) = копия )
   */
arr.fill(100, 1, 4);//заполняет числом 100 от 1 индекса до 4. Передав таким образом массив, метод его не раскидает, а целиком будет совать в каждую ячейку

arr.join();//склеивает массив в строку. Принимает разделитель 
arr.toString();//тот же join но без сепаратора

/**######--Переборы--######## */
arr.forEach(()=>{});//цикл
arr.map(()=>{});//тот же forEarch только может возвращять резуоттат  

let count = 0;
let some = arr.some(elem => {
    if(elem == 60)
        return true
    count++;
    console.dir(count);//перебирает до тех пока не найдёт. Потом выходит
})
//аналогично если был forEach с командой breck; 

arr.reduce();//находит сумму всего массива.
//timeSumm - ячейка для в которой храниться сумма на этапе сложения.item - каждое значение
let summ = arr1.reduce((timeSumm, item) => {

  return timeSumm + item;
}, 0);//начальное значение. total называется.
/*
  ПРОЧИТАТЬ. Немного экспериментов с методом reduce дали понять некоторые вещи.
  метод делает цикл из стольки элементов сколько дал ему в обработку это и логично, но вот что интересно
  проверяя через console.dir() 1й и 2й параметры я заметил, о чём раньше и неподозревал:
  При отсутствии return мы получим в 1м параметре total и кучу undefined/

  Если я пытаюсь вернуть 2й элемент то reduce вынужден пробежаться по циклу и передавать значениея, по которым проходится,
  и передаёт в 1й парметр поэтому вижу изменения 1го параметра, если я пытаюсь вернуть 1й параметр, то ничего кроме total'a
  или если его нет, то 1го элемента массива я не увижу т.к. сложения элементов не происходит,
  ведь оно неуказано и в цикле. 
  *Если я не укажу return то вообще увижу что reduce один раз передаёт в 1й параметр 
  одно значение, остальные undefined, а во 2й оставшиеся и последний undefined/

  Вообщем соржновато для понимания. Что я понял, что если мы требуем 1й параметр то он неизменно повториться в цикле 
  столько насколько забит массив, если ворачивать 2й элемент, то все значения пройдёт через 1й и вернёться только последний
  элемент что это даёт. Увидел такое решение в интернете. Врят ли я вообще вспомню когда его
  это решить лечше через цикл и Object.assing
*/
const arr1 = [
  { test: [1] },
  { test2: [2] },
  { test3: [3] },
  { test4: [4] },
  { test5: [5] },
  { test6: [6] },
  { test7: [7] }
];
let ob = arr1.reduce((a, b) => { 
    return {...a,...b};
});

console.dir(ob);
//сокращённая запись
arr1.reduce((a, b) => ({...a,...b}));

/*
и сколько б не экспериментировал больше ничего толкового с этим методом не сделал.
вообщем любой цикл и сделано
*/
let arrOb = {};
for(let i of arr1) Object.assign(arrOb, i) //проще

console.dir(arrOb);

let arrObj = {};
arr1.forEach((i) => Object.assign(arrObj, i) ) //или

console.dir(arrObj);

/**######-----------######## */


arr.filter((item)=>{
    return item > 30;
});//возвращает отфильтрованый массив
arr.sort((value1,value2)=>{
    return (value2 - value1)
});//возвращает сортированый массив. Изменяет основной. Сортирует от меньшего к большему и на оборот. Всплытие пузырька про который я смотрел
//и т.д. некоторые не записал. работа с bool
/*--------------------------------------------------------------------------------------------------------------------------------------------*/
let obj = {
    name: 'Alex',
    age: 21,
    city: 'NewYork',
    number: 15,
    [Symbol('foo')]: 'sikret',//такое свойство не изменить
    get _number(){  return this.number  },
    set _number(value){
      if(value > 0 && value <= 20)
        this.number = value 
      else{
        let strErr = (value < 0)? 'Меньше: 0' : 'Больше: 20';
        console.dir(strErr);
      } 
    }
}

let obj1 = Object.assign({}, obj);//ES5 копировать объект в новый. Передать можно много объектов
let obj2 = {...obj1};//ES6

obj._number = 21;
console.dir(obj);
/*
  На вопрос: "Что такое десткриптор" - это некий контролирующий функционал который можно изменять влияя на 
  доступ, изменение и удаление свойст и методов, точно не уверен возможно и объектов.
  и имеет некий контролирующий функционал для этого свойства. Например напрямую через метод defineProperty
  или косвенно через set и get.  
  Что нам даёт set и get. По сути мы же может обратиться напрямую к свойству и его изменить.
  Да можем. Обращаясю через set и get мы может устанавливать (контролировать) логику изменения для свойства
  т.к. внутри объекта set и get ведут себя как функции.
  Конечно что бы нельзя было напрямую что то менять в свойстве то есть defineProperty
*/

Object.defineProperty(obj, 'name1', {
    enumerable: false,//будет ли св-во перечисляемым
    configurable: false,//можно ли удалять c помощью delete, модифицировать св-во
    writable: false,//можно ли изменить значение
    value: 'Борис',//значение свойства
   
  });
  /*
    дабавление свойства объекту которое можно контролировать.
    1е. в какой объект
    2е. какое свойство
    3е. объект параметров для этого свойства.
    НЕДОСТАТОК. такой метод нужно на каждое свойство
  */
  obj.name1 = 'ss';//не изменится
  delete obj.name1;//не удалиться
//для многих свойств
  Object.defineProperties(obj, { 
    name1: {
      enumerable: false,//будет ли св-во перечисляемым
      configurable: false,//можно ли удалять c помощью delete, модифицировать св-во
      writable: false,//можно ли изменить значение
      value: 'Борис'//значение свойства
      },
    name2: {
      enumerable: false,//будет ли св-во перечисляемым
      configurable: false,//можно ли удалять c помощью delete, модифицировать св-во
      writable: false,//можно ли изменить значение
      value: 'Петян'//значение свойства
    }
  });

  Object.freeze(obj);//замораживает объект, устанавливая дескрипторы configurable и writable в false.

  let dest = Object.getOwnPropertyDescriptor(obj, 'name1');//узнаёт состояние дескрипторов


 Object.create();//Если требуеться передать объекту узел prototype в наследство. Читать в конце ООП main.js


 
