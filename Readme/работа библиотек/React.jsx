/*eslint-disable */
/*--О структуре компонентов.. 
Часто методы и свойства хранятся выше по структуре. Зачем?
  1. для того что бы контролировать и обеспечивать разные компоненты одними и теми же методами и свойствами    
  2. оставить более чистые дочерние компоненты
  Передавать данные можно через props и между компонентом в поле children.
  Передавать можно даже компоненты
*/

  
<SplitPane left={ <Contacts />} right={ <Chat /> } />;
props.children - /*для примитивов свойство, для переданной функции - метод props.children() */
                            
<Fragment></Fragment>; //пустая обёртка или так <> </> 

"-----------------------------------------------------------------------"
"#######----<{ Компонент и метод. Обязательно для прочтения }>---#######"
let Forma = (props) => <div></div>;
<Component> { Forma } </Component>;//Forma передаёт вызов метода
<Component> <Forma/> </Component>;//<Forma/> передаёт объект компонента
/*
  В обоих случаях { Forma } <Forma/> мы передаём в родителя Component.
  { Forma }
  Вызывая эту функцию в родителе через props.children(), получаем специальный объект, который на самом деле 
  описывает те jsx теги которые вернула нам функцию Forma. То есть возвращает нам к примеру <div></div> получаем
  {type: 'div', props: {}- пустой} Если есть вложенность <div> 15 <p>15</p> </div>, то 
  {props: {children: ['15', {объект type: 'p'}]}}.
  Это обычный вызов функции и props не появиться если ничего не передать.
  *Передать мы передадим, но нам надо это отрисовать, а не как с обычной функцией поработать.
  Каждый родитель это может сделать, нужно просто вернуть родителем этот объект.
  Родитель передаст его по конвейеру в React.render и получаем поведение как у обычных тегов.
  1. Для отрисовки родитель должен передавать объект вызванного компонента
  2. Имеются ли планы наполнять эту функцию через родителя? Если нет, то вызвать мы можем его
     и вне родителя { Forma() } главное чтоб родитель возвращал этот объект в React.render.

  <Forma/>
  Такая запись внутри родителя это не вызов функции Forma, это оборачивание, запись в виде
  JSX компонента. Любая запись в виде JSX, React воспринимает это как объект.
  В предыдущем случае мы в ручную вызывали и получали элементы JSX, видели это объектом.
  Здесь запуском заниматься будет React но только если мы передадим компонент (объект)
  родителю. Мы обернули функцию. Теперь type указывает на функцию
  {type: (props) =>{}, props: {}} и когда мы вернём родителем такую запись что бы отрисовалась эта функция
  то React в 1ю очередь вызовет эту функцию потом передаст в него те props которые были указаны в 
  JSX записи.  <Forma str="Hi" />   props: {str: 'Hi'}
   
ВАЖНО. Смысла компонент оборачивать компонентом нет, т.к. React должен знать что за обёрткой
стоит функция (или класс), после вызова которого он передаст props обёртки компонента на вход этой функции.
 
*/
<Component1 myProp={'data'}>{ Component2 }</Component1>;
<Component1 myProp={'data'}><Component2 m={15}/></Component1>;

let Component1 = (props) => {
/* props: получаем Component2 + свои props{children: props => { } ||  myProp: "data"}
   props.children() JSX {type: 'form': props: {children: {JSX} }}
   <props.children m={15}> JSX {type: (props) => {} props: {m: 15}}
*/
  let newData = {
    ...props,
    method1: (a) => {},
    method2: (b) => {},
    property: 11
  }
/*В React передаём Об.Комп. Component2 будет запущен*/
  return props.children(newData) || <props.children {...newData}/>
/*
  Если так передан <Component2 m={15}/> то имеем объект. Двойной вызов делать нельзя
  <props.children>, поэтому делаем так: 
*/
  return {...props.children, props: {...props.children.props, ...newData}}
}
let Component2 = (props) => {
 /*props: {method1: a => {}, method2: b => {}, property: 11}*/
  return (
    <form>
      <input type="text"/>
    </form>
)}
/*
  ВАЖНО Запомнить: 
  1. {Component2} - вызов функции. родителем может быть обычный вызов и передача props в ручную или 
                    использование обёртки JSX. Как задумал разработчик Родительского компонента. 
  2. <Component2/> - Обёртка JSX. Вызов функции в обёртке совершает React с передачей props обёртки
  3. Для отрисовки родитель должен возвращать JSX объект вложенности.
  
  Не мало ВАЖНО 
    Функции которые использоваться будут в Обёртке JSX компонента нужно указывать с большой буквы
    Иначе React не будет вызывать функцию 
  Так же следует помнить что в обоих случая мы передавали в JSX компонент
  Есть варианты передавать в обычную функцию это уже HOC варианты
*/

let method = (props) => 15;//обычная функция
let Comp1 = (props) => <div></div>;//компонент
//По соглашению компоненты должны писать с заглавной буквы.
{method};//родитель должен обработать. Многие разрабы ждут <method/>, а не { method }
<method/>;//сделали компонентом. рассчитываем что родитель передаст props. Об.Комп. показывает type: props => { return 15 }

{Comp1};//опять же зависит от настройки родителя. Может не обработать. Как настроил разраб.
{Comp1()};// Можно конечно вернуть JSX, но если это будет неизвестный компонент будет ошибка
<Comp1/>;//норма. рассчитываем на props

//Запись не верна. JS ошибки не выдаст.
let Comp2 = (Component) => <Component m={15}/>;//Это должно быть функцией
<Comp2/> //родитель передаст props, и <props/> делать не верно и бессмысленно  
let A = Comp2();//вернул неизвестный компонент.
<A/>//Сделал двойной вызов. type: {$$typeof: Symbol(react.elem)}




"-----------------------------------------------------------------------"
"#########-------<{ Некоторые фишки и рекомендации }>-------#########"

arr.map((item) => (/*При итерации можем передать что-нибудь в событие*/ 
  <div onClick={(e)=>{ this.evChange(e, item.number) }}>item.number</div>
));

"-----------------------------------------------------------------------"
"#########-------<{ Наследованные методы и методы React }>-------#########"
render()//обновляется в 1ю очередь при изменении компонента и первоначальной загрузки страницы
componentDidMount()//отрабатывает после render 1 раз, то есть после того как DOM отрисовался 
componentDidUpdate(prevProps, prevState)//обновляется после render и только если были изменения компонента 

React.createRef()//присвоим экземпляр будем получать элементам можем получить их свойства
const Context = React.createContext('light');//создание контекста. Принимает defaultValue

<Context.Provider value="dark">  <MyComponent /> </Context.Provider>
// Импортируем Context. 
/* в классовой компоненте можно передать в объект context через contextType */
class newComponent {  static contextType = Context; }//передаём dark
//Общий вариант
<Context.Consumer>{value => { /* value = dark */}}</Context.Consumer>;

const Component3 = (props) => {
  const formikStateAndHelpers = useFormik(props);
  return (
    <Context.Provider value={formikStateAndHelpers} >/*слежка и передача ниже */
      {typeof children === 'function'
        ? children(formikStateAndHelpers)//если родитель передал функцию.
        : children}
    </Context.Provider>
  );
}


"-----------------------------------------------------------------------"
"#########-------<{ Объект события React }>-------#########"
onFocus//реагирует при фокусировке на элементе
/* свойства и методы класса event */
/*
  В React над обычным объектом Event есть обёртка SyntheticEvent которая при вызове события 
  передаёт данные в event и очищается. (сделано это дял производительности. Поэтому я ничего там
  не видел, только после вызова). Что бы исключить этот объект из потока и использовать асинхронно
  нужно вызвать e.persist()
*/
e.bubbles//является ли событие всплывающим в DOM :=> bool
e.cancelable//является ли событие отменяемым :=> bool
e.charCode//хз но вместо кода клавиши возвращает 0
e.ctrlKey//был ли нажат Ctrl
e.shiftKey//был ли нажат Shift

e.currentTarget//target тот на котором висит событие. Не важно если кликаем на дочерний элемент
e.target//если событие на родителе, то в target попадает тот элемент на который тыкнули
e.defaultPrevented//информирует был ли в событии установлен e.preventDefault() :=> bool
e.detail//возвращает число кликов по событию. Клики засчитываются если интервал чуть меньше секунды иначе сбрасывается 
e.dispatchConfig//описывает что за событие отработало
e.eventPhase//возвращает число типа event: Ev.NONE = 0 Ev.CAPTURING_PHASE = 1 Ev.AT_TARGET = 2 Ev.BUBBLING_PHASE = 3
e.getModifierState("Shift")//была ли нажата. На всю клавиатуру не распространяется, только определённые кнопки. читать Modifier keys on Gecko
e.keyCode || e.which //определяют код клавиши 
e.type//определяет чем нажато. Смысла от этого нет т.к. я определяю событиями мыши или клавы 
e.timeStamp//показывает число в промежутке времени котором было отработано событие
e.nativeEvent//js нативый event


/*
    Пропускаем по 2м линкам внутри Component1 проверяем линки и подгружаем нужный
    компонент
  <Route path={['/', '/login']} component={Component1}></Route>
 */
//setState в render и componentDidUpdate использовать можно только в условии которое ограничит и не даст бесконечно перерисовывать компонент 

"-----------------------------------------------------------------------"
"#########-------<{ стандартные props для компонентов }>-------#########"

/*
Заметка
  Иногда при построении сайтов предусматривают вариант для людей с ограниченными возможностями
  Когда проектируются такие решения нужно использовать не camelCase а kebab-case.
  В React есть атрибут aria-* и целый список возможностей. 
*/