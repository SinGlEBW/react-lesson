.test-block{
    display: grid;
    background-color: #33343A;
    border: 1px solid #000;
 }
 
 .test-block__form{
    display: grid;
    grid-row-gap: 20px;
    border: 1px solid red; 
 }

 .text-block__items{
    display: grid;
    grid-template-columns: repeat(12,1fr);
    grid-template-rows: 1fr 50px;
    grid-gap: 10px;
    align-items: center;
    border: 3px solid #000;
    padding: 20px;
 }
 .text-block__item{
    margin-left: 20px;
}
 .text-block__buttons{
    display: grid;
    grid-template-columns: repeat(12,1fr);
    padding: 20px;
 }

 .text-block__item:first-child{
    grid-column: 1 / -1;
    margin-left: 10px;
 }
 .item__textarea{
    height: 100px;
 }
 .text-block__btn{
    display: grid;
    grid-row: 2 / -1;
    grid-gap: 0px;
    height: 30px;
    width: 100px;
    align-content: center;
    align-self: center;
   
   
}



/*
   Ещё одно странное поведение grid.
   При использовании единицы fr добавляя кол-во строк, grid ориентируется на высоту блока. Высота либо задана
   либо определяется контентом. Если задать высоту дочернего элемента и создать предположим 5 строк,
   будет 5 равных строк высоте дочернего элемента, но если обратиться к элементу и попытаться распределить
   (растянуть) элемент на 3 строки grid-row: 1/4 то блок останется того же размера, произойдёт новый пересчёт
   статический размер блока будет поделен на 3 равные части которые как бы и займут 3 строки и за блоком будут
   вынесены ещё 2 строки с новым размером. Общий размер родителя тупо уменьшиться. 

   Вывод, при растяжении по вертикали требуется статический размер строк
*/
 /*
   Некоторые проблемы с которыми встретился в grid на React. При построении страницы
   2м блоком ставиться container. В grid нужно указывать сетку родителю. в container 
   смысла, ставить сетку, нет. тогда придётся дополнительно делать обёртку или
   отказываться от контейнера. В таком случае обёртки всё равно не миновать, 
   и указывать сетку настраивать можно разного размера для каждой обёртки.
   Не знаю на сколько это актуально, но пока рассматриваю такой вариант в целях 
   выравнивание элементов за счёт сетки. Чтоб лишних элементов сетки не было на которые 
   придётся наезжать если элемент будет находиться не в поле колонки
 
   При использовании grid-template-rows(columns) на дочерних элементах при использовании
   общего класса нужно понимать что команды grid воздействуют на каждый элемент 
   в отдельности
 
   При использовании единиц измерения vh, можно попасть в просак пытаясь делать расстояние 
   между элементами, элементы могут выходить за пределы родителя. Что бы этого избежать 
   высоту или выбирать заведомо большей контента или ставить в процентах или вовсе не указывать
 
 */


 
/*
grid-column-start: 1;передвижение непосредственно элемента. указав 2му элементу переместиться на позицию 1, он перейдёт 
                     на 2ю строку, а не сдвинет 1й элемент.Перемещение же вправо будет сдвигать элементы строки
grid-column-end: 5; указывает границу до какого элемента
grid-column: 3/5; - альтернативная запись

При обращение к элементам с параметром сдвига в строке, элементы почему-то начинают движение не со своей позиции, а с
левого края сдвигая всё на своём пути

grid-row-start: 1; начало строки
grid-row-end: 3; до какой строки. Освободит строку под элементом если что-то там есть
grid-row: 1/3; альтернатива

другой способ контроля позиций элементов. В родителе можно указать
 grid-template-columns: repeat(12, 1fr);
 grid-template-areas:
        "h h h h h h h h h h h h h"
        "m m c c c c c c c c c c c"
        "f f f f f f f f f f f f f";







Особенности отличий flex от grid:
  1. при объявлении flex переводит колонку в строку, grig делает элементы блочными, но не разворачивает в строку
 
  2. в grid есть понятие "СЕТКА" и добавлены метод и так же изменены методы из flex:
     align-items, justify-items - выравнивают в СЕТКЕ по вертикали и горизонтали, указываются в родителе,
     в то время в flex нет justify-items и align-items просто выравнивает по вертикали.

  3. в grid за простое выравнивание элементов в родителе отвечают методы align-content, justify-content,
     в то время как в flex align-content выравнивает по вертикали если есть 2 и более строк.
     
     Важно: Разница между align-content и align-item. align-content выравнивает элементы по верхней части 
     самого высокого элемента. Это значит берётся самый высокий элемент, выравнивается (допустим по центру 'center')
     и остальные элементы держаться в ровную линию верней части элемента, не смотря на свои размеры.
     align-item выравнивает элементы по положениям которые запрашиваем. Если center, то по общему центру
     если end то выравниет по нижнему краю.
    
  4. у flex для дочернего элемента есть align-self которая выравнивает по той оси которая установлена методом flex-direction, 
     в то время как в grid есть как горизонтальное так и вертикальное управление align-self, justify-self.
###------------------------------------------------------------------------------------------------------------
  Для grid align-content, align-items, align-self одно и тоже, разница лишь в том что можно в отдельности
  управлять одним дочерним элементом через align-self. Для flex тож самое исключая align-content)

  Так же не стоит забывать, что flex - это блок, из-за перехода с колонки в строку блок div растягивается уже не
  по горизонтали, а по вертикали, за это отвечает параметр на дочерний эл. align-self: по ум stretch 

  Интересная особенность. При указании flex или grid дочерний элемент растягивается по высоте родителя.
  За высотой родителя нужно следить, тогда из-за растянутого дочернего элемента не возникнет проблем
  использовать align-content
  Так же при добавлении элементов, в растянутый блок родителя при использовании grid, они распределяются 
  равномерно по вертикали 

  Использование flex и grid не влияет на перемещение родителя
###-------------------------------------------------------------------------------------------------------------
  
      
  Не допускать в grid
1. Если идёт управление размером через родителя, то указывать размер в дочернем элементе не стоит
  не смотря на то что размер дочернего элемента мы изменим, значение родителя не поменяется
  и ориентироваться придётся на установленный размер родителя, что не очень удобно и приводит к непредсказуемым результатам.

*/

/*
  Различия подходов flex и grid.
  Что бы выровнять во flex и grid элементах дочерний элемент с контентом, требуется дочернему элементу(тобишь родителю для своей вложенности)
  задать размер после добавить display: flex(grid) и далее jc-center. 
  в grig есть понятие колонок в связи с которыми приходиться вводить доп параметры в родителе
  Пример.
  Из-за того что в grid выставлены колонки в родителе, для выравнивания элементов в них, в родителе задаётся есть параметр для колонок
  justify-items: center. Во flex не пришлось бы ничего указывать дополнительно т.к. он не строит колонки 
 
*/

/*
   last-child обращение происходит на дочернем элементе которые завязаны под один класс.
   Нужно удостовериться что на этом же уровне не присутствует в конце других элементов с другим классом
   иначе last-child не отработает.
*/