/*eslint-disable*/
//коллекции это массивы состоящие из объектов
Array
/*
  @@ - возвращает новый не изменяя старый
  ^^ - изменяет старый массив так и возвращает новый
  && - примитив
  <> - объект
  Предикат - логическое выражение основа которого true или false
*/

/*#####>>>>--- ИЗМЕНЕНИЕ СТРУКТУРЫ МАССИВА (Не убавилось, не прибавилось) ---<<<<###### */
//@@ массив разбивает на равные части с остатком или без.
chunk(['a', 'b', 'c', 'd'], 2); // => [['a', 'b'], ['c', 'd']]
//@@ убирает вложенность массива на 1. обычный arr.flat и то полезней
flatten([1, [2, [3, [4]], 5]]);// => [1, 2, [3, [4]], 5] 
//@@ убирает полностью все вложенности в массиве
flattenDeep([1, [2, [3, [4]], 5]]);// => [1, 2, 3, 4, 5]
//@@ тот же arr.flat, но со своим синтаксисом
flattenDepth(array, 1);// => [1, 2, [3, [4]], 5]
/*<> принимает массив с массивами ключ значение*/
fromPairs([['a', 1], ['b', 2]]);// => { 'a': 1, 'b': 2 }
//@@ конвертирует объект в массив с массивами. ключ значение. Не наследует данные из prototype
toPairs({a: 1, b: 2});// => [["a", 1], ["b", 2]]
//@@ так же наследует свойство из prototype
    function Foo() {  this.a = 1; this.b = 2; }
    Foo.prototype.c = 3;//1го уровня данные
toPairsIn(new Foo());// => [['a', 1], ['b', 2], ["c", 3]] 
//&& склеивает по сепаратору. Обычный join
join(['a', 'b', 'c'], '~');// => 'a ~ b ~ c'
//@@ Разворачивает массив
reverse([2, 3, 5, 4]);// => [4, 5, 3, 2]


/*#####>>>>--- ВНЕДРЕНИЕ В МАССИВ ---<<<<###### */
//@@ обычный arr.concat 
concat(array, 2, [3], [[4]]);// => [1, 2, 3, [4]].
//^^ тот же arr.fill заполняет массив значением от - до.
fill(arr1, 'a', 2);// => [2, 3, "a", "a", "a"]


/*#####>>>>--- ФИЛЬТРЫ (Найти и исключить) ---<<<<###### */
//@@ исключает из массива false, null, 0, "", undefined и NaN. return массив
compact([0, 1, false, 2, '', 3]);// => [1, 2, 3]
//^^ исключает из массива те значения которые указываются в любом кол-ве через запятую
pull(['a', 'b', 'c', 'd'], 'a', 'c');// => ['b', 'd']
//^^ исключает из массива те значения которые указываются массивом во 2м параметре
pullAll(['a', 'b', 'c', 'd'], ['a', 'c']);// => ['b', 'd'];
//^^ тож самое + критерий. В данном случае по ключу "x"
pullAllBy([{ x: 1 }, { x: 2 }], [{ 'x': 1 }], 'x');// => [{ 'x': 2 }]
//^^ версия с компаратором
pullAllWith([{ x: 1 }, { x: 2 }], [{ x: 1 }], _.isEqual);// => [{ x: 2 }]
//^^ исключает элементы по индексам и массив вырезанных значений. Индекс нач. с 1, а не с 0
pullAt('a', 'b', 'c', 'd', [1, 3]);// => ['b', 'd']
//@@ тот же pullAll, но не изменяет старый массив
//обычный difference не распознаёт объекты для их фильтрования и удаления найденных ключей
difference([2, 1, 5], [2, 3]);// => [1,5]
//@@ + добавляется метод для каждой итерации (Как критерий сравнения). итерация нач. со 2го массива, заканчивается проходом по 1му
//это значит Math.floor сокращает в мен. сторону, делается сравнение, лишнее выводиться как есть
differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor)// => [1.2]
//@@ добавляется метод влияющий на сравнения так же объектов для исключения из 1го массива
//итерация. 1й эл 1 массива - проход по 2му массиву, 2й - эл массива и снова проход 2 массиву и т.д
//итерация. каждый элемент 1го массива проходится полностью по 2му массиву
differenceWith([2, 4], [2, 5], _.isEqual)// => [4]
//@@ исключает последнего элемента в массиве.
initial([1, 3, 4]);// => [1, 3]
//@@ исключает из начала массива 1 и более индексов.  2й пар. n-число. 1й элемент можно не указывать
drop([1, 2, 3]);// => [2,3]
//@@ исключает с конца массива 1 и более индексов. тот же initial только имеет 2й параметр.
dropRight([1, 2, 3, 4, 5], 2);// => [1, 2, 3]
//@@ исключает с конца массива используя Предикат. удаляет пока видит false или true. Пример
let users = [
  { 'user': 'barney',  'active': true },
  { 'user': 'fred',    'active': false },
  { 'user': 'pebbles', 'active': true },
];
dropRightWhile(users, (o)=>!o.active)// => { 'user': 'barney',  'active': true },
//@@ удаление спереди 
dropWhile(users, ['active', true])//вернёт массив с 2мя объектами fred и pebbles
//^^ Работает как filter, возвращает элементы равные условию предиката: true
remove([13, 14, 12, 1, 5], (a)=> !(a % 2))
//@@ возвращает элементы равные условию предиката: true
filter([13, 14, 12, 1, 5])
//@@ возвращает новый массив по на основе старого по указанным позициям индексов
slice([13, 14, 12, 1, 5], 1, 3);// => [14, 12]. Конечный индекс не включительно
/*#####>>>>--- ПОИСК ПО МАССИВУ (Найти и вернуть)---<<<###### */
//&& возвращает 1й эл. массива. Обычный arr.shift вырезает 1й элемент в отличие от head
head([2, 2, 3])// => 2
//возвращает последний эл. массива. Обычный arr.pop, но не изменяет массив
last([1, 2, 3]);// => 3. Антоним initial
//&& тот же findIndex. 2й параметр можно указывать так же как в dropRightWhile
findIndex(arr2, (i) => i === 5)// => 2 индекс.
//&& возвращает последний индекс. 2й пар. и findLastIndex превращается в findIndex
findLastIndex(arr)//принимает так же Предикат (логическое выражение которое при итерации опирается на bool)
//&& обычный arr.indexOf. ищет по значению индекс. 3й пар. "Ищи значение после n индексов". 
indexOf(arr1, 3);// => 1.//установив отрицательное смещение, поиск будет с конца 
//&& 3й пар. звучит так "Ищи значение в первых n индексах"
lastIndexOf([1, 2, 3, 4, 5], 3, 2);// => -1 . Не дотянулся
//&& ищет значение по индексу. Отрицательный индекс ищет с конца
nth([1, 2, 3, 4, 5], 2);// => 3
//@@ сравнивает массивы и возвращает сходство. Объекты не сравнивает
intersection([2, 1], [2, 3])// => 2
//@@ то же действие + критерий сравнения. Можно сравнить объекты по критериям ключа
intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);// => [2.1]
//@@ 3й параметр компаратор сравнения. 2ва аргумента arrVal1, arrVal2. Можно _.isEqual
//Принцип работы. Ищет a1 > a2 пока не достигнет конца или 1го или 2го массива
intersectionWith([2,3,3], [2,2,1], (a1, a2) => a1 > a2);// => [2]-уникальна
//@@ Осуществляет двоичный поиск значения(бинарный). Возвращает индекс по которому можно вставить в этот массив это значение
//и не потерять сортировку. При несортированном методе т.к. бинарный поиск это постоянное деление массива поровну
//сложно предугадать куда поиск предполагает нахождение данного элемента Запутанный метод. Читать про линейный и двоичный поиск
//На во много раз быстрей происходит поиск дынный чем линейный поиск. Пригодиться при оптимизации запросов от пользователя
sortedIndex()//предварительно нужно отсортировать массив как я понял