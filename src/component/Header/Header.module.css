.header {
  display: grid;
  background-color: #282c34;
  border: 3px solid #000;
  background: url(/image/header.jfif);
  background-size: cover;

 }
.wrap{
  display: grid;
  grid-template-rows: 400px 1fr;
  border: 1px solid green;
}
.nav {
  list-style-type: none;  
  display: flex;
  justify-content: space-around;
  align-items: flex-end;
  
  padding-bottom: 50px;
  border: 1px solid #000;
}
.item {
  box-shadow: 0px 0px 20px black;

}

.link {
  display: grid;
  justify-content: center;
  align-items: center;
  width: 200px;
  height: 70px;
  border: 1px solid #876;
  text-decoration: none;

  font-size: 1.7rem;
  
  background: linear-gradient(45deg, #FE6B8B 30%, #FF8E53 90%);
  border: 2px solid #000;
  border-radius: 4px;
  box-shadow: 0 0 0 2px rgba(255, 105, 135, .3), inset 0 0 0 5px rgba(2, 2, 2, 0.3);
}

 /*
  container имеет grid, дочерние элементы занимают равномерную площадь по высоте. При изменении
  размеров дочерних элементов остаётся так же невидимое поле равномерно распределяющее элементы.
  Без родительского вмешательства имеется инструмент перемещений с префиксом self и перемещаться 
  можно только по этим площадям выделенным для каждого элемента. 
  Сокращать дистанцию в таком случае придётся использовав отрицательные значения margin.
  При положительном значении margin, если элементы не упираются, то они будут отталкиваться друг от друга  
  Странное поведение. При отталкивании элементом от другого элемента, центр начинает смещаться 
  в сторону того элемента поэтому 2й(другой) элемент начинает двигаться, но расстояние рассчитывается
  поровну от центра которого не видно 
 */